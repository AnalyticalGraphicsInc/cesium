<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <meta
      name="description"
      content="Visualize worldwide, high-resolution terrain."
    />
    <meta name="cesium-sandcastle-labels" content="Tutorials, Showcases" />
    <title>Cesium Demo</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script
      type="text/javascript"
      src="../../../Build/CesiumUnminified/Cesium.js"
      nomodule
    ></script>
    <script type="module" src="../load-cesium-es6.js"></script>
  </head>
  <body
    class="sandcastle-loading"
    data-sandcastle-bucket="bucket-requirejs.html"
  >
    <style>
      @import url(../templates/bucket.css);
    </style>
    <div id="cesiumContainer" class="fullSize"></div>
    <div id="loadingOverlay"><h1>Loading...</h1></div>
    <div id="toolbar">
      <div id="terrainMenu"></div>
      <div id="zoomButtons"></div>
      <div id="showQuadtreeLevel"></div>
      <div id="showTestedTriangles"></div>
      <div id="sampleButtons"></div>
    </div>
    <script id="cesium_sandcastle_script">
      function startup(Cesium) {
        "use strict";

        //Sandcastle_Begin
        var worldTerrain = Cesium.createWorldTerrain({
          requestWaterMask: true,
          requestVertexNormals: true,
        });

        var arcGisTerrainProvider = new Cesium.ArcGISTiledElevationTerrainProvider(
          {
            url:
              "https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer",
          }
        );

        var locationOptions = [
          {
            name: "Mount Everest",
            target: new Cesium.Cartesian3(
              300770.50872389384,
              5634912.131394585,
              2978152.2865545116
            ),
            offset: new Cesium.Cartesian3(
              6344.974098678562,
              -793.3419798081741,
              2499.9508860763162
            ),
          },
          {
            name: "Half Dome",
            target: new Cesium.Cartesian3(
              -2489625.0836225147,
              -4393941.44443024,
              3882535.9454173897
            ),
            offset: new Cesium.Cartesian3(
              -6857.40902037546,
              412.3284835694358,
              2147.5545426812023
            ),
          },
          {
            name: "San Francisco Bay",
            target: new Cesium.Cartesian3(
              -2708814.85583248,
              -4254159.450845907,
              3891403.9457429945
            ),
            offset: new Cesium.Cartesian3(
              70642.66030209465,
              -31661.517948317807,
              35505.179997143336
            ),
          },
        ];

        var viewer = new Cesium.Viewer("cesiumContainer", {
          terrainProvider: arcGisTerrainProvider,
        });
        viewer.scene.globe.enableLighting = false;
        viewer.scene.fog.enabled = false;

        window.viewer = viewer;

        var selectedQuadTreeAtLevel = null;
        var showTestedTriangles = false;

        var quadTreeDataSource = new Cesium.CustomDataSource("quadtree");

        var intersectedTriangleDataSource = new Cesium.CustomDataSource(
          "intersectedTriangleDataSource"
        );
        var testedTrianglesDataSource = new Cesium.CustomDataSource(
          "testedTrianglesDataSource"
        );
        var testedPointsDataSource = new Cesium.CustomDataSource(
          "testedPoints"
        );
        var axisPrimitiveCollection = new Cesium.PrimitiveCollection();

        viewer.dataSources.add(quadTreeDataSource);
        viewer.dataSources.add(intersectedTriangleDataSource);
        viewer.dataSources.add(testedTrianglesDataSource);
        viewer.dataSources.add(testedPointsDataSource);
        viewer.scene.primitives.add(axisPrimitiveCollection);

        function localToWorld(transform, local) {
          return Cesium.Matrix4.multiplyByPoint(
            transform,
            local,
            new Cesium.Cartesian3()
          );
        }

        function drawQuadTreeNode(transform, node, color) {
          var topLeft = node.topLeft;
          var bottomRight = node.bottomRight;
          var minHeight = node.minHeight;
          var maxHeight = node.maxHeight;

          var topLeftWorldSpace = localToWorld(
            transform,
            new Cesium.Cartesian3(topLeft.x, topLeft.y, 0)
          );
          var bottomRightWorldSpace = localToWorld(
            transform,
            new Cesium.Cartesian3(bottomRight.x, bottomRight.y, 0)
          );

          var minHeightWorldSpace = localToWorld(
            transform,
            new Cesium.Cartesian3(0, 0, minHeight)
          );
          var maxHeightWorldSpace = localToWorld(
            transform,
            new Cesium.Cartesian3(0, 0, maxHeight)
          );

          var topLeftCartographic = Cesium.Cartographic.fromCartesian(
            topLeftWorldSpace
          );
          var bottomRightCartographic = Cesium.Cartographic.fromCartesian(
            bottomRightWorldSpace
          );
          var minHeightCartographic = Cesium.Cartographic.fromCartesian(
            minHeightWorldSpace
          );
          var maxHeightCartographic = Cesium.Cartographic.fromCartesian(
            maxHeightWorldSpace
          );

          var rect = new Cesium.Rectangle(
            topLeftCartographic.longitude,
            topLeftCartographic.latitude,
            bottomRightCartographic.longitude,
            bottomRightCartographic.latitude
          );

          quadTreeDataSource.entities.add({
            rectangle: {
              coordinates: rect,
              material: color,
              rotation: Cesium.Math.toRadians(0),
              extrudedHeight: maxHeightCartographic.height,
              height: minHeightCartographic.height,
              outline: true, // height must be set for outline to display
              outlineColor: Cesium.Color.BLACK,
            },
          });
        }

        function addDot(transform, local, color, radius) {
          radius = radius || 50;
          var point = localToWorld(transform, local);
          viewer.entities.add({
            position: point,
            ellipsoid: {
              radii: new Cesium.Cartesian3(50.0, 50.0, 50.0),
              material: color,
            },
          });
        }

        function drawPointList(color, dataSource, points) {
          if (points && points.length) {
            for (var i = 0; i < points.length; i++) {
              var p = points[i];
              dataSource.entities.add({
                position: p,
                ellipsoid: {
                  radii: new Cesium.Cartesian3(10.0, 10.0, 10.0),
                  material: color,
                },
              });
            }
          }
        }

        function sortCartesianList(values) {
          return values.slice(0).sort(function (a, b) {
            return a.x - b.x;
          });
        }

        function isTriangleAlmostEqual(a, b) {
          a = sortCartesianList(a);
          b = sortCartesianList(b);
          return (
            isCartesianAlmostEqual(a[0], b[0]) &&
            isCartesianAlmostEqual(a[1], b[1]) &&
            isCartesianAlmostEqual(a[2], b[2])
          );
        }

        function isCartesianAlmostEqual(a, b) {
          return (
            a &&
            b &&
            Math.abs(a.x - b.x) < 0.1 &&
            Math.abs(a.y - b.y) < 0.1 &&
            Math.abs(a.z - b.z) < 0.1
          );
        }

        function drawTriangleList(color, dataSource, triangles) {
          if (triangles && triangles.length) {
            for (var i = 0; i < triangles.length; i++) {
              var tri = triangles[i];
              dataSource.entities.add({
                polygon: {
                  hierarchy: tri,
                  perPositionHeight: true,
                  material: color,
                  outline: true,
                  outlineColor: color,
                  outlineWidth: 10,
                },
              });
            }
          }
        }

        Sandcastle.addDefaultToolbarMenu(
          locationOptions.map(function (option) {
            return {
              text: option.name,
              onselect: function () {
                viewer.camera.lookAt(option.target, option.offset);
                viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
              },
            };
          }),
          "zoomButtons"
        );

        function flatten(node) {
          if (!node) {
            return [];
          }
          return [node]
            .concat(flatten(node.topLeftTree))
            .concat(flatten(node.bottomLeftTree))
            .concat(flatten(node.topRightTree))
            .concat(flatten(node.bottomRightTree));
        }

        function showIntersectedTriangles() {
          intersectedTriangleDataSource.entities.removeAll();
          var oldTriangle =
            window.lastPickDetails &&
            window.lastPickDetails.traceDetails &&
            window.lastPickDetails.traceDetails.oldIntersectedTriangle;
          var newTriangle =
            window.lastPickDetails &&
            window.lastPickDetails.traceDetails &&
            window.lastPickDetails.traceDetails.newIntersectedTriangle;

          if (
            oldTriangle &&
            newTriangle &&
            isTriangleAlmostEqual(oldTriangle, newTriangle)
          ) {
            drawTriangleList(
              Cesium.Color.GREEN,
              intersectedTriangleDataSource,
              [newTriangle]
            );
          } else {
            drawTriangleList(
              Cesium.Color.GOLD,
              intersectedTriangleDataSource,
              oldTriangle && [oldTriangle]
            );

            drawTriangleList(
              Cesium.Color.BLUE,
              intersectedTriangleDataSource,
              newTriangle && [newTriangle]
            );
          }
        }

        function setShowTestTriangles(value) {
          testedTrianglesDataSource.entities.removeAll();
          testedPointsDataSource.entities.removeAll();

          if (value) {
            var triangles =
              (window.lastPickDetails &&
                window.lastPickDetails.traceDetails &&
                window.lastPickDetails.traceDetails.testedTriangles) ||
              [];
            drawTriangleList(
              Cesium.Color.ORANGE,
              testedTrianglesDataSource,
              triangles
            );

            // var points =
            //   (window.lastPickDetails &&
            //     window.lastPickDetails.traceDetails &&
            //     window.lastPickDetails.traceDetails.testedPoints) ||
            //   [];
            // drawPointList(Cesium.Color.PINK, testedPointsDataSource, points);
          }
        }

        function drawRectangle(rect) {}

        function showQuadTreeAtLevel(level) {
          if (window.lastPickDetails) {
            var root = window.lastPickDetails.mesh._trianglePicking._quadtree;
            var transform = window.lastPickDetails.traceDetails.transform;

            var nodes = flatten(root);
            var nodesAtLevel = nodes.filter(function (n) {
              return n.level === level;
            });

            quadTreeDataSource.entities.removeAll();
            for (var i = 0; i < nodesAtLevel.length; i++) {
              var n = nodesAtLevel[i];
              var color = Cesium.Color.GREEN.withAlpha(0.05);
              if (n.isHit) {
                color = Cesium.Color.GOLD.withAlpha(0.2);
              }
              drawQuadTreeNode(transform, n, color);
            }
          }
        }

        function getShowAtLevelFn(level) {
          return function () {
            selectedQuadTreeAtLevel = level;
            showQuadTreeAtLevel(selectedQuadTreeAtLevel);
          };
        }

        var showQuadTreeOptions = [
          {
            text: "Hide Quadtree",
            onselect: getShowAtLevelFn(null),
          },
        ];
        var optionLevel = 0;
        while (optionLevel < 6) {
          showQuadTreeOptions.push({
            text: "Quadtree Level " + optionLevel,
            onselect: getShowAtLevelFn(optionLevel),
          });
          optionLevel++;
        }

        Sandcastle.addToolbarMenu(showQuadTreeOptions, "showQuadtreeLevel");
        Sandcastle.addToolbarMenu(
          [
            {
              text: "Hide Tested Triangles",
              onselect: function () {
                showTestedTriangles = false;
                setShowTestTriangles(showTestedTriangles);
              },
            },
            {
              text: "Show Tested Triangles",
              onselect: function () {
                showTestedTriangles = true;
                setShowTestTriangles(showTestedTriangles);
              },
            },
          ],
          "showTestedTriangles"
        );

        var scene = viewer.scene;
        var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);

        handler.setInputAction(function (movement) {
          window.showPickDetails = true;
          var scene = viewer.scene;
          var camera = scene.camera;

          var ray = camera.getPickRay(movement.position);
          var pickPosition = scene.globe.pick(ray, scene);

          window.showPickDetails = false;

          var details = window.lastPickDetails;
          console.trace("details here");

          if (details) {
            viewer.entities.removeAll();

            debugger;
            var transform = details.traceDetails.transform;

            var axis = new Cesium.DebugModelMatrixPrimitive({
              modelMatrix: transform,
              length: 100000.0,
              width: 2.0,
            });
            axisPrimitiveCollection.removeAll();
            axisPrimitiveCollection.add(axis);

            viewer.entities.add({
              name: "ray",
              position: Cesium.Cartesian3.ZERO,
              polyline: {
                positions: [ray.origin, Cesium.Ray.getPoint(ray, 10000)],
                material: Cesium.Color.GOLDENROD,
              },
            });

            // draw the tile rectangle
            // viewer.entities.add({
            //   id: "tile-rect",
            //   rectangle: {
            //     coordinates: details.mesh._trianglePicking._rectangle,
            //     material: Cesium.Color.CYAN.withAlpha(0.5),
            //     rotation: Cesium.Math.toRadians(0),
            //     extrudedHeight: 10000,
            //     height: 0,
            //     outline: true,
            //     outlineColor: Cesium.Color.BLACK,
            //   },
            // });

            setShowTestTriangles(showTestedTriangles);
            showIntersectedTriangles();
            showQuadTreeAtLevel(selectedQuadTreeAtLevel);
          }
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

        //Sandcastle_End
        Sandcastle.finishedLoading();
      }
      if (typeof Cesium !== "undefined") {
        window.startupCalled = true;
        startup(Cesium);
      }
    </script>
  </body>
</html>
