<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">  <!-- Use Chrome Frame in IE -->
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <meta name="description" content="Geometry and Appearances.">
    <meta name="cesium-sandcastle-labels" content="Showcases">
    <title>Cesium Demo</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script type="text/javascript" src="../../../ThirdParty/requirejs-2.1.9/require.js"></script>
    <script type="text/javascript">
    require.config({
        baseUrl : '../../../Source',
        waitSeconds : 60
    });
    </script>
</head>
<body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html" data-sandcastle-title="Cesium + require.js">
<style>
    @import url(../templates/bucket.css);
</style>
<div id="cesiumContainer" class="fullSize"></div>
<div id="loadingOverlay"><h1>Loading...</h1></div>
<div id="toolbar"></div>
<script id="cesium_sandcastle_script">
require(['Cesium'], function(C) {
    "use strict";

    C.Math.setRandomNumberSeed(1234);
    var viewer = new C.Viewer('cesiumContainer');
    var scene = viewer.scene;
    var primitives = scene.primitives;
    var solidWhite = C.ColorGeometryInstanceAttribute.fromColor(C.Color.WHITE);

    // Combine instances for an rectangle, polygon, ellipse, and circle into a single primitive.

    var rectangle = C.Rectangle.fromDegrees(-92.0, 20.0, -86.0, 27.0);
    var rectangleInstance = new C.GeometryInstance({
        geometry : new C.RectangleGeometry({
            rectangle : rectangle,
            vertexFormat : C.EllipsoidSurfaceAppearance.VERTEX_FORMAT,
            stRotation : C.Math.toRadians(45)
        })
    });
    var rectangleOutlineInstance = new C.GeometryInstance({
        geometry : new C.RectangleOutlineGeometry({
            rectangle : rectangle
        }),
        attributes : {
            color : solidWhite
        }
    });

    var positions = C.Cartesian3.fromDegreesArray([
        -107.0, 27.0,
        -107.0, 22.0,
        -102.0, 23.0,
        -97.0, 21.0,
        -97.0, 25.0
    ]);

    var polygonInstance = new C.GeometryInstance({
        geometry : C.PolygonGeometry.fromPositions({
            positions : positions,
            vertexFormat : C.EllipsoidSurfaceAppearance.VERTEX_FORMAT
        })
    });
    var polygonOutlineInstance = new C.GeometryInstance({
        geometry : C.PolygonOutlineGeometry.fromPositions({
            positions : positions
        }),
        attributes : {
            color : solidWhite
        }
    });

    var center = C.Cartesian3.fromDegrees(-80.0, 25.0);
    var semiMinorAxis = 300000.0;
    var semiMajorAxis = 500000.0;
    var rotation = C.Math.toRadians(-40.0);
    var ellipseInstance = new C.GeometryInstance({
        geometry : new C.EllipseGeometry({
            center : center,
            semiMinorAxis : semiMinorAxis,
            semiMajorAxis : semiMajorAxis,
            rotation : rotation,
            stRotation : C.Math.toRadians(22),
            vertexFormat : C.EllipsoidSurfaceAppearance.VERTEX_FORMAT
        })
    });
    var ellipseOutlineInstance = new C.GeometryInstance({
        geometry : new C.EllipseOutlineGeometry({
            center : center,
            semiMinorAxis : semiMinorAxis,
            semiMajorAxis : semiMajorAxis,
            rotation : rotation
        }),
        attributes : {
            color : solidWhite
        }
    });

    center = C.Cartesian3.fromDegrees(-72.0, 25.0);
    var radius = 250000.0;
    var circleInstance = new C.GeometryInstance({
        geometry : new C.CircleGeometry({
            center : center,
            radius : radius,
            stRotation : C.Math.toRadians(90),
            vertexFormat : C.EllipsoidSurfaceAppearance.VERTEX_FORMAT
        })
    });
    var circleOutlineInstance = new C.GeometryInstance({
        geometry : new C.CircleOutlineGeometry({
            center : center,
            radius : radius
        }),
        attributes : {
            color : solidWhite
        }
    });

    primitives.add(new C.Primitive({
        geometryInstances : [rectangleInstance, polygonInstance, ellipseInstance, circleInstance],
        appearance : new C.EllipsoidSurfaceAppearance({
            material : C.Material.fromType('Stripe')
        })
    }));
    primitives.add(new C.Primitive({
        geometryInstances : [rectangleOutlineInstance, polygonOutlineInstance, ellipseOutlineInstance, circleOutlineInstance],
        appearance : new C.PerInstanceColorAppearance({
            flat : true,
            translucent : false,
            renderState : {
                depthTest : {
                    enabled : true
                },
                lineWidth : Math.min(4.0, scene.maximumAliasedLineWidth)
            }
        })
    }));

    // Create extruded rectangle
    rectangle = C.Rectangle.fromDegrees(-118.0, 38.0, -116.0, 40.0);
    var extrudedHeight = 500000.0;
    var extrudedRectangle = new C.GeometryInstance({
        geometry : new C.RectangleGeometry({
            rectangle : rectangle,
            vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT,
            extrudedHeight : extrudedHeight
        }),
        attributes : {
            color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 1.0}))
        }
    });

    var extrudedOutlineRectangle = new C.GeometryInstance({
        geometry : new C.RectangleOutlineGeometry({
            rectangle : rectangle,
            extrudedHeight : extrudedHeight
        }),
        attributes : {
            color : solidWhite
        }
    });

    // Create extruded ellipse
    center = C.Cartesian3.fromDegrees(-117.0, 35.0);
    semiMinorAxis = 100000.0;
    semiMajorAxis = 200000.0;
    rotation = C.Math.toRadians(90);
    var height = 100000.0;
    extrudedHeight = 200000.0;
    var extrudedEllipse = new C.GeometryInstance({
        geometry : new C.EllipseGeometry({
            center : center,
            semiMinorAxis : semiMinorAxis,
            semiMajorAxis : semiMajorAxis,
            vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT,
            height : height,
            rotation : rotation,
            extrudedHeight : extrudedHeight
        }),
        attributes : {
            color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 1.0}))
        }
    });
    var extrudedOutlineEllipse = new C.GeometryInstance({
        geometry : new C.EllipseOutlineGeometry({
            center : center,
            semiMinorAxis : semiMinorAxis,
            semiMajorAxis : semiMajorAxis,
            height : height,
            rotation : rotation,
            extrudedHeight : extrudedHeight
        }),
        attributes : {
            color : solidWhite
        }
    });

    // Create extruded polygon
    var polygonHierarchy = {
        positions : C.Cartesian3.fromDegreesArray([
            -118.0, 30.0,
            -115.0, 30.0,
            -117.1, 31.1,
            -118.0, 33.0
        ])
    };
    height = 300000.0;
    extrudedHeight = 700000.0;
    var extrudedPolygon = new C.GeometryInstance({
        geometry : new C.PolygonGeometry({
            polygonHierarchy : polygonHierarchy,
            vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT,
            extrudedHeight : extrudedHeight,
            height : height
        }),
        attributes : {
            color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 1.0}))
        }
    });
    var extrudedOutlinePolygon = new C.GeometryInstance({
        geometry : new C.PolygonOutlineGeometry({
            polygonHierarchy : polygonHierarchy,
            extrudedHeight : extrudedHeight,
            height : height
        }),
        attributes : {
            color : solidWhite
        }
    });

    // cylinder
    var length = 200000.0;
    var topRadius = 150000.0;
    var bottomRadius = 150000.0;
    var modelMatrix = C.Matrix4.multiplyByTranslation(C.Transforms.eastNorthUpToFixedFrame(
        C.Cartesian3.fromDegrees(-70.0, 45.0)),
        new C.Cartesian3(0.0, 0.0, 100000.0), new C.Matrix4());
    var cylinderInstance = new C.GeometryInstance({
        geometry : new C.CylinderGeometry({
            length : length,
            topRadius : topRadius,
            bottomRadius : bottomRadius,
            vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT
        }),
        modelMatrix : modelMatrix,
        attributes : {
            color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 1.0}))
        }
    });
    var cylinderOutlineInstance = new C.GeometryInstance({
        geometry : new C.CylinderOutlineGeometry({
            length : length,
            topRadius : topRadius,
            bottomRadius : bottomRadius
        }),
        modelMatrix : modelMatrix,
        attributes : {
            color : solidWhite
        }
    });

    primitives.add(new C.Primitive({
        geometryInstances : [extrudedPolygon, extrudedRectangle, extrudedEllipse, cylinderInstance],
        appearance : new C.PerInstanceColorAppearance({
            translucent : false,
            closed : true
        })
    }));
    primitives.add(new C.Primitive({
        geometryInstances : [extrudedOutlineRectangle, extrudedOutlineEllipse, extrudedOutlinePolygon, cylinderOutlineInstance],
        appearance : new C.PerInstanceColorAppearance({
            flat : true,
            translucent : false,
            renderState : {
                depthTest : {
                    enabled : true
                },
                lineWidth : Math.min(4.0, scene.maximumAliasedLineWidth)
            }
        })
    }));

    // Create box and ellipsoid boxes, and use the instance's
    // modelMatrix to scale and position them.
    var dimensions = new C.Cartesian3(1.0, 1.0, 1.0);
    var boxGeometry = C.BoxGeometry.fromDimensions({
        vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT,
        dimensions : dimensions
    });
    var boxOutlineGeometry = C.BoxOutlineGeometry.fromDimensions({
        dimensions : dimensions
    });

    var radii = new C.Cartesian3(0.5, 0.5, 1.0);
    var ellipsoidGeometry = new C.EllipsoidGeometry({
        vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT,
        radii : radii
    });

    var ellipsoidOutlineGeometry = new C.EllipsoidOutlineGeometry({
        radii : radii,
        stackPartitions : 6,
        slicePartitions : 5
    });

    radius = 0.75;
    var sphereGeometry = new C.SphereGeometry({
        vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT,
        radius : radius
    });

    var sphereOutlineGeometry = new C.SphereOutlineGeometry({
        radius : radius,
        stackPartitions : 6,
        slicePartitions : 5
    });

    var instances = [];
    var outlineInstances = [];
    var i;
    var boxModelMatrix, ellipsoidModelMatrix, sphereModelMatrix;
    for (i = 0; i < 5; ++i) {
        height = 100000.0 + (200000.0 * i);
        boxModelMatrix = C.Matrix4.multiplyByUniformScale(C.Matrix4.multiplyByTranslation(C.Transforms.eastNorthUpToFixedFrame(
            C.Cartesian3.fromDegrees(-106.0, 45.0)), new C.Cartesian3(0.0, 0.0, height), new C.Matrix4()), 90000.0, new C.Matrix4());
        ellipsoidModelMatrix = C.Matrix4.multiplyByUniformScale(C.Matrix4.multiplyByTranslation(C.Transforms.eastNorthUpToFixedFrame(
            C.Cartesian3.fromDegrees(-102.0, 45.0)), new C.Cartesian3(0.0, 0.0, height), new C.Matrix4()), 90000.0, new C.Matrix4());
        sphereModelMatrix = C.Matrix4.multiplyByUniformScale(C.Matrix4.multiplyByTranslation(C.Transforms.eastNorthUpToFixedFrame(
            C.Cartesian3.fromDegrees(-98.0, 45.0)), new C.Cartesian3(0.0, 0.0, height), new C.Matrix4()), 90000.0, new C.Matrix4());

        instances.push(new C.GeometryInstance({
            geometry : boxGeometry,
            modelMatrix : boxModelMatrix,
            attributes : {
                color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 1.0}))
            }
        }));
        outlineInstances.push(new C.GeometryInstance({
            geometry : boxOutlineGeometry,
            modelMatrix : boxModelMatrix,
            attributes : {
                color : solidWhite
            }
        }));

        instances.push(new C.GeometryInstance({
            geometry : ellipsoidGeometry,
            modelMatrix : ellipsoidModelMatrix,
            attributes : {
                color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 1.0}))
            }
        }));
        outlineInstances.push(new C.GeometryInstance({
            geometry : ellipsoidOutlineGeometry,
            modelMatrix : ellipsoidModelMatrix,
            attributes : {
                color : solidWhite
            }
        }));

        instances.push(new C.GeometryInstance({
            geometry : sphereGeometry,
            modelMatrix : sphereModelMatrix,
            attributes : {
                color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 1.0}))
            }
        }));
        outlineInstances.push(new C.GeometryInstance({
            geometry : sphereOutlineGeometry,
            modelMatrix : sphereModelMatrix,
            attributes : {
                color : solidWhite
            }
        }));
    }

    primitives.add(new C.Primitive({
        geometryInstances : instances,
        appearance : new C.PerInstanceColorAppearance({
            translucent : false,
            closed : true
        })
    }));
    primitives.add(new C.Primitive({
        geometryInstances : outlineInstances,
        appearance : new C.PerInstanceColorAppearance({
            flat : true,
            translucent : false,
            renderState : {
                depthTest : {
                    enabled : true
                },
                lineWidth : Math.min(4.0, scene.maximumAliasedLineWidth)
            }
        })
    }));

    // Create a single wall
    positions = C.Cartesian3.fromDegreesArray([
        -95.0, 50.0,
        -85.0, 50.0,
        -75.0, 50.0
    ]);
    var maximumHeights = [500000, 1000000, 500000];
    var minimumHeights = [0, 500000, 0];

    var wallInstance = new C.GeometryInstance({
        geometry : new C.WallGeometry({
            positions : positions,
            maximumHeights : maximumHeights,
            minimumHeights : minimumHeights
        }),
        attributes : {
            color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 0.7}))
        }
    });

    var wallOutlineInstance = new C.GeometryInstance({
        geometry : new C.WallOutlineGeometry({
            positions : positions,
            maximumHeights : maximumHeights,
            minimumHeights : minimumHeights
        }),
        attributes : {
            color : new C.ColorGeometryInstanceAttribute(0.7, 0.7, 0.7, 1.0)
        }
    });

    scene.primitives.add(new C.Primitive({
        geometryInstances : wallInstance,
        appearance : new C.PerInstanceColorAppearance()
    }));
    primitives.add(new C.Primitive({
        geometryInstances : wallOutlineInstance,
        appearance : new C.PerInstanceColorAppearance({
            flat : true,
            translucent : false,
            renderState : {
                depthTest : {
                    enabled : true
                },
                lineWidth : Math.min(4.0, scene.maximumAliasedLineWidth)
            }
        })
    }));

    rectangle = C.Rectangle.fromDegrees(-92.0, 30.0, -85.0, 40.0);
    rectangleInstance = new C.GeometryInstance({
        geometry : new C.RectangleGeometry({
            rectangle : rectangle,
            vertexFormat : C.EllipsoidSurfaceAppearance.VERTEX_FORMAT
        })
    });

    polygonHierarchy = {
        positions : C.Cartesian3.fromDegreesArray([
            -109.0, 30.0,
            -95.0, 30.0,
            -95.0, 40.0,
            -109.0, 40.0
        ]),
        holes : [{
            positions : C.Cartesian3.fromDegreesArray([
                -107.0, 31.0,
                -107.0, 39.0,
                -97.0, 39.0,
                -97.0, 31.0
            ]),
            holes : [{
                positions : C.Cartesian3.fromDegreesArray([
                    -105.0, 33.0,
                    -99.0, 33.0,
                    -99.0, 37.0,
                    -105.0, 37.0
                ]),
                holes : [{
                    positions : C.Cartesian3.fromDegreesArray([
                        -103.0, 34.0,
                        -101.0, 34.0,
                        -101.0, 36.0,
                        -103.0, 36.0
                    ])
                }]
            }]
        }]
    };
    polygonInstance = new C.GeometryInstance({
        geometry : new C.PolygonGeometry({
            polygonHierarchy : polygonHierarchy,
            vertexFormat : C.EllipsoidSurfaceAppearance.VERTEX_FORMAT
        })
    });

    center = C.Cartesian3.fromDegrees(-80.0, 35.0);
    semiMinorAxis = 200000.0;
    semiMajorAxis = 500000.0;
    rotation = C.Math.toRadians(30.0);
    ellipseInstance = new C.GeometryInstance({
        geometry : new C.EllipseGeometry({
            center : center,
            semiMinorAxis : semiMinorAxis,
            semiMajorAxis : semiMajorAxis,
            rotation : rotation,
            vertexFormat : C.EllipsoidSurfaceAppearance.VERTEX_FORMAT
        })
    });

    center = C.Cartesian3.fromDegrees(-72.0, 35.0);
    radius = 200000.0;
    circleInstance = new C.GeometryInstance({
        geometry : new C.CircleGeometry({
            center : center,
            radius : radius,
            vertexFormat : C.EllipsoidSurfaceAppearance.VERTEX_FORMAT
        })
    });

    primitives.add(new C.Primitive({
        geometryInstances : [rectangleInstance, polygonInstance, ellipseInstance, circleInstance],
        appearance : new C.EllipsoidSurfaceAppearance({
            material : C.Material.fromType('Stripe')
        })
    }));

    // Create extruded rectangle
    rectangle = C.Rectangle.fromDegrees(-110.0, 38.0, -107.0, 40.0);
    height = 700000.0;
    extrudedHeight = 1000000.0;
    rotation = C.Math.toRadians(45.0);
    extrudedRectangle = new C.GeometryInstance({
        geometry : new C.RectangleGeometry({
            rectangle : rectangle,
            vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT,
            height : height,
            rotation : rotation,
            extrudedHeight : extrudedHeight
        }),
        attributes : {
            color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 1.0}))
        }
    });

    // Create extruded ellipse
    center = C.Cartesian3.fromDegrees(-110.0, 35.0);
    semiMinorAxis = 100000.0;
    semiMajorAxis = 200000.0;
    rotation = C.Math.toRadians(-40.0);
    height = 300000.0;
    extrudedHeight = 700000.0;
    extrudedEllipse = new C.GeometryInstance({
        geometry : new C.EllipseGeometry({
            center : center,
            semiMinorAxis : semiMinorAxis,
            semiMajorAxis : semiMajorAxis,
            rotation : rotation,
            vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT,
            height : height,
            extrudedHeight : extrudedHeight
        }),
        attributes : {
            color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 1.0}))
        }
    });

    // Create extruded polygon
    polygonHierarchy = {
        positions : C.Cartesian3.fromDegreesArray([
            -113.0, 30.0,
            -110.0, 30.0,
            -110.0, 33.0,
            -111.5, 31.0,
            -113.0, 33.0
        ])
    };
    extrudedHeight = 300000.0;
    extrudedPolygon = new C.GeometryInstance({
        geometry : new C.PolygonGeometry({
            polygonHierarchy : polygonHierarchy,
            vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT,
            extrudedHeight : extrudedHeight
        }),
        attributes : {
            color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 1.0}))
        }
    });

    // cylinder
    length = 400000.0;
    topRadius = 0.0;
    bottomRadius = 200000.0;
    modelMatrix = C.Matrix4.multiplyByTranslation(C.Transforms.eastNorthUpToFixedFrame(
        C.Cartesian3.fromDegrees(-70.0, 40.0)), new C.Cartesian3(0.0, 0.0, 200000.0), new C.Matrix4());
    cylinderInstance = new C.GeometryInstance({
        geometry : new C.CylinderGeometry({
            length : length,
            topRadius : topRadius,
            bottomRadius : bottomRadius,
            vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT
        }),
        modelMatrix : modelMatrix,
        attributes : {
            color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 1.0}))
        }
    });

    primitives.add(new C.Primitive({
        geometryInstances : [extrudedPolygon, extrudedRectangle, extrudedEllipse, cylinderInstance],
        appearance : new C.PerInstanceColorAppearance({
            translucent : false,
            closed : true
        })
    }));

    // Combine instances each with a unique color.
    // We can combine heterogeneous geometries as we
    // do here as long as vertex formats match.
    instances = [];

    center = C.Cartesian3.fromDegrees(-65.0, 35.0);
    radius = 200000.0;
    rectangle = C.Rectangle.fromDegrees(-67.0, 27.0, -63.0, 32.0);
    for (i = 0; i < 5; ++i) {
        height = 200000.0 * i;

        instances.push(new C.GeometryInstance({
            geometry : new C.CircleGeometry({
                center : center,
                radius : radius,
                height : height,
                vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT
            }),
            attributes : {
                color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 0.5}))
            }
        }));

        instances.push(new C.GeometryInstance({
            geometry : new C.RectangleGeometry({
                rectangle : rectangle,
                height : height,
                vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT
            }),
            attributes : {
                color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 0.5}))
            }
        }));
    }

    primitives.add(new C.Primitive({
        geometryInstances : instances,
        appearance : new C.PerInstanceColorAppearance()
    }));

    // Create box and ellipsoid boxes, and use the instance's
    // modelMatrix to scale and position them.
    dimensions = new C.Cartesian3(1.0, 1.0, 1.0);
    boxGeometry = C.BoxGeometry.fromDimensions({
        vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT,
        dimensions : dimensions
    });

    radii = new C.Cartesian3(0.5, 0.5, 1.0);
    ellipsoidGeometry = new C.EllipsoidGeometry({
        vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT,
        radii : radii
    });

    radius = 0.75;
    sphereGeometry = new C.SphereGeometry({
        vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT,
        radius : radius
    });

    instances = [];
    outlineInstances = [];
    for (i = 0; i < 5; ++i) {
        height = 100000.0 + (200000.0 * i);
        boxModelMatrix = C.Matrix4.multiplyByUniformScale(C.Matrix4.multiplyByTranslation(C.Transforms.eastNorthUpToFixedFrame(
            C.Cartesian3.fromDegrees(-108.0, 45.0)), new C.Cartesian3(0.0, 0.0, height), new C.Matrix4()), 90000.0, new C.Matrix4());
        ellipsoidModelMatrix = C.Matrix4.multiplyByUniformScale(C.Matrix4.multiplyByTranslation(C.Transforms.eastNorthUpToFixedFrame(
            C.Cartesian3.fromDegrees(-104.0, 45.0)), new C.Cartesian3(0.0, 0.0, height), new C.Matrix4()), 90000.0, new C.Matrix4());
        sphereModelMatrix = C.Matrix4.multiplyByUniformScale(C.Matrix4.multiplyByTranslation(C.Transforms.eastNorthUpToFixedFrame(
            C.Cartesian3.fromDegrees(-100.0, 45.0)), new C.Cartesian3(0.0, 0.0, height), new C.Matrix4()), 90000.0, new C.Matrix4());
        instances.push(new C.GeometryInstance({
            geometry : boxGeometry,
            modelMatrix : boxModelMatrix,
            attributes : {
                color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 0.5}))
            }
        }));

        instances.push(new C.GeometryInstance({
            geometry : ellipsoidGeometry,
            modelMatrix : ellipsoidModelMatrix,
            attributes : {
                color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 0.5}))
            }
        }));

        instances.push(new C.GeometryInstance({
            geometry : sphereGeometry,
            modelMatrix : sphereModelMatrix,
            attributes : {
                color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 0.5}))
            }
        }));
    }

    primitives.add(new C.Primitive({
        geometryInstances : instances,
        appearance : new C.PerInstanceColorAppearance({
            translucent : true,
            closed : true
        })
    }));

    positions = [];
    var colors = [];
    for (i = 0; i < 40; ++i) {
        positions.push(C.Cartesian3.fromDegrees(-100.0 + i, 48.0));
        colors.push(C.Color.fromRandom({alpha : 1.0}));
    }

    primitives.add(new C.Primitive({
        geometryInstances : new C.GeometryInstance({
            geometry : new C.SimplePolylineGeometry({
                positions : positions,
                colors : colors
            })
        }),
        appearance : new C.PerInstanceColorAppearance({
            flat : true,
            renderState : {
                depthTest : {
                    enabled : true
                },
                // Override the appearance render state to change the
                // line width on system's that support it (Linx/Mac).
                lineWidth : Math.min(4.0, scene.maximumAliasedLineWidth)
            }
        })
    }));

    // create a polyline with a material
    positions = [];
    for (i = 0; i < 40; ++i) {
        positions.push(C.Cartesian3.fromDegrees(-100.0 + i, 15.0));
    }

    primitives.add(new C.Primitive({
        geometryInstances : new C.GeometryInstance({
            geometry : new C.PolylineGeometry({
                positions : positions,
                width : 10.0,
                vertexFormat : C.PolylineMaterialAppearance.VERTEX_FORMAT
            })
        }),
        appearance : new C.PolylineMaterialAppearance({
            material : C.Material.fromType(C.Material.PolylineGlowType)
        })
    }));

    // create a polyline with per segment colors
    positions = [];
    colors = [];
    for (i = 0; i < 40; ++i) {
        positions.push(C.Cartesian3.fromDegrees(-100.0 + i, 12.0));
        colors.push(C.Color.fromRandom({alpha : 1.0}));
    }

    primitives.add(new C.Primitive({
        geometryInstances : new C.GeometryInstance({
            geometry : new C.PolylineGeometry({
                positions : positions,
                width : 10.0,
                vertexFormat : C.PolylineColorAppearance.VERTEX_FORMAT,
                colors : colors
            })
        }),
        appearance : new C.PolylineColorAppearance()
    }));

    // create a polyline with per vertex colors
    positions = [];
    colors = [];
    for (i = 0; i < 40; ++i) {
        positions.push(C.Cartesian3.fromDegrees(-100.0 + i, 9.0));
        colors.push(C.Color.fromRandom({alpha : 1.0}));
    }

    primitives.add(new C.Primitive({
        geometryInstances : new C.GeometryInstance({
            geometry : new C.PolylineGeometry({
                positions : positions,
                width : 10.0,
                vertexFormat : C.PolylineColorAppearance.VERTEX_FORMAT,
                colors : colors,
                colorsPerVertex : true
            })
        }),
        appearance : new C.PolylineColorAppearance()
    }));

    // Create a single wall
    positions = C.Cartesian3.fromDegreesArrayHeights([
        -90.0, 43.0, 100000.0,
        -87.5, 45.0, 100000.0,
        -85.0, 43.0, 100000.0,
        -87.5, 41.0, 100000.0,
        -90.0, 43.0, 100000.0
    ]);

    wallInstance = new C.GeometryInstance({
        geometry : new C.WallGeometry({
            positions : positions
        })
    });

    scene.primitives.add(new C.Primitive({
        geometryInstances : wallInstance,
        appearance : new C.MaterialAppearance({
            material : C.Material.fromType('Checkerboard', {
                repeat : new C.Cartesian2(20.0, 6.0)
            })
        })
    }));

    positions = C.Cartesian3.fromDegreesArray([
        -120.0, 45.0,
        -125.0, 50.0,
        -125.0, 55.0
    ]);
    var width = 100000;

    var corridor = new C.GeometryInstance({
        geometry : new C.CorridorGeometry({
            positions : positions,
            width : width,
            vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT
        }),
        attributes : {
            color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 1.0}))
        }
    });

    var extrudedCorridor = new C.GeometryInstance({
        geometry : new C.CorridorGeometry({
            positions : positions,
            width : width,
            vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT,
            height : 300000,
            extrudedHeight : 400000
        }),
        attributes : {
            color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 0.7}))
        }
    });

    var corridorOutline = new C.GeometryInstance({
        geometry : new C.CorridorOutlineGeometry({
            positions : positions,
            width : width,
            height : 700000
        }),
        attributes : {
            color : solidWhite
        }
    });

    var corridorFill = new C.GeometryInstance({
        geometry : new C.CorridorGeometry({
            positions : positions,
            width : width,
            vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT,
            height : 700000
        }),
        attributes : {
            color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 0.7}))
        }
    });

    primitives.add(new C.Primitive({
        geometryInstances : [corridor, extrudedCorridor, corridorFill],
        appearance : new C.PerInstanceColorAppearance({
            translucent : true,
            closed : true
        })
    }));

    primitives.add(new C.Primitive({
        geometryInstances : corridorOutline,
        appearance : new C.PerInstanceColorAppearance({
            flat : true,
            translucent : false,
            renderState : {
                depthTest : {
                    enabled : true
                },
                lineWidth : Math.min(4.0, scene.maximumAliasedLineWidth)
            }
        })
    }));

    function starPositions(arms, rOuter, rInner) {
        var angle = Math.PI / arms;
        var pos = [];
        for ( var i = 0; i < 2 * arms; i++) {
            var r = (i % 2) === 0 ? rOuter : rInner;
            var p = new C.Cartesian2(Math.cos(i * angle) * r, Math.sin(i * angle) * r);
            pos.push(p);
        }
        return pos;
    }

    positions = C.Cartesian3.fromDegreesArrayHeights([
        -102.0, 15.0, 100000.0,
        -105.0, 20.0, 200000.0,
        -110.0, 20.0, 100000.0
    ]);
    var polylineVolumeFill = new C.GeometryInstance({
        geometry : new C.PolylineVolumeGeometry({
            polylinePositions : positions,
            vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT,
            shapePositions : starPositions(7, 30000.0, 20000.0)
        }),
        attributes : {
            color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 1.0}))
        }
    });

    var polylineVolumeOutline = new C.GeometryInstance({
        geometry : new C.PolylineVolumeOutlineGeometry({
            polylinePositions : positions,
            shapePositions : starPositions(7, 30000.0, 20000.0)
        }),
        attributes : {
            color : solidWhite
        }
    });

    var polylineVolume = new C.GeometryInstance({
        geometry : new C.PolylineVolumeGeometry({
            polylinePositions : C.Cartesian3.fromDegreesArray([
                -102.0, 15.0,
                -105.0, 20.0,
                -110.0, 20.0
            ]),
            vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT,
            shapePositions : starPositions(7, 30000, 20000)
        }),
        attributes : {
            color : C.ColorGeometryInstanceAttribute.fromColor(C.Color.fromRandom({alpha : 1.0}))
        }
    });

    function computeCircle(radius) {
        var positions = [];
        for (var i = 0; i < 360; i++) {
            var radians = C.Math.toRadians(i);
            positions.push(new C.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));
        }
        return positions;
    }

    var tubeGeometry = new C.GeometryInstance({
        geometry : new C.PolylineVolumeGeometry({
            polylinePositions : C.Cartesian3.fromDegreesArray([
                -104.0, 13.0,
                -107.0, 18.0,
                -112.0, 18.0
            ]),
            vertexFormat : C.PerInstanceColorAppearance.VERTEX_FORMAT,
            shapePositions : computeCircle(40000.0)
        }),
        attributes : {
            color : solidWhite
        }
    });

    primitives.add(new C.Primitive({
        geometryInstances : [tubeGeometry, polylineVolume, polylineVolumeFill],
        appearance : new C.PerInstanceColorAppearance({
            translucent : false,
            closed : true
        })
    }));

    primitives.add(new C.Primitive({
        geometryInstances : polylineVolumeOutline,
        appearance : new C.PerInstanceColorAppearance({
            flat : true,
            translucent : false,
            renderState : {
                depthTest : {
                    enabled : true
                },
                lineWidth : 1.0
            }
        })
    }));

    Sandcastle.finishedLoading();
});
</script>
</body>
</html>
